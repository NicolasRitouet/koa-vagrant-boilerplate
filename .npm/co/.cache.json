{"_id":"co","_rev":"37-31b6518a24bf2d82309e43a2590162bf","name":"co","description":"generator async flow control goodness","dist-tags":{"latest":"3.0.2"},"versions":{"1.0.0":{"name":"co","version":"1.0.0","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.10.0"},"license":"MIT","readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks instead of promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony` or `--harmony-generators` flags when\n  running node 0.11.x to get access to generators.\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  - [co-fs](https://github.com/visionmedia/co-fs) - core `fs` function wrappers\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})\n```\n\n## Why not promises?\n\n  I'm not a fan of promises personally, but preferences aside this\n  is an extremely minimal layer between the traditional node `(err, result)`\n  style callback using thunks. All you need to do is return a function, this\n  function behaves as the \"thunk\" or \"future\" that is `yield`ed to Co.\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n  This is what the `co.wrap(fn)` utility function does for you.\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` which is immediately invoked. Any `yield` expressions\n  within _must_ return a \"thunk\", at which point `co()` will defer execution.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\n#### Nesting co() calls\n\n  The `co()` function itself returns a thunk, this means you can nest appropriately:\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nvar foo = co(function *(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n})\n\nvar bar = co(function *(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n})\n\nco(function *(){\n  var a = yield foo;\n  var b = yield bar;\n  console.log(a);\n  console.log(b);\n});\n```\n\n  Or a variation of the same thing:\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = yield co(function *(){\n    var a = yield size('.gitignore');\n    var b = yield size('Makefile');\n    var c = yield size('package.json');\n    return [a, b, c];\n  })\n\n  var b = yield co(function *(){\n    var a = yield size('examples/parallel.js');\n    var b = yield size('examples/nested.js');\n    var c = yield size('examples/simple.js');\n    return [a, b, c];\n  })\n\n  console.log(a);\n  console.log(b);\n});\n```\n\n#### co() return values\n\n  Since `co()` returns a thunk, you may pass a function to this thunk\n  to receive the `return` values from the generator. Any error that occurs\n  is passed to this (`sizes`) function.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nvar sizes = co(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a.length, b.length, c.length];\n});\n\nsizes(function(err, res){\n  console.log(res);\n});\n```\n\n### co.wrap(fn, [ctx])\n\n  The `co.wrap()` utility simply wraps a node-style function to return a thunk.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile', 'ascii');\n  var c = yield read('package.json', 'utf8');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\nOptionally you may pass the `fn`'s receiver as the `ctx` as shown here:\n\n```js\n\nvar co = require('co')\nvar redis = require('redis')\nvar db = redis.createClient()\n\ndb.set = co.wrap(db.set, db)\ndb.get = co.wrap(db.get, db)\n\nco(function *(){\n  yield db.set('foo', 'bar')\n  yield db.set('bar', 'baz')\n\n  var res = yield db.get('foo')\n  console.log('foo -> %s', res);\n\n  var res = yield db.get('bar')\n  console.log('bar -> %s', res);\n})\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n## FAQ\n\n### How does this compare to taskjs?\n\n  - it's smaller\n  - it's not a scheduler\n  - it doesn't use promises\n\n### What's this \"yielded a non-function\" error?\n\n  If you get this error it means that you're passing\n  a value that is _not_ a function to `yield`, for example\n  `yield \"something\"`, which has no meaning to `co`.\n\n### Does it work with streams?\n\n  Not out of the box, but if you're willing to fight node a bit you can\n  wrestle streams into something usable:\n\n```js\nco(function *(){\n  var res = yield get('http://google.com');\n  console.log('-> %s', res.status);\n\n  var buf;\n  while (buf = yield res.read()) {\n    console.log(buf.toString());\n  }\n\n  console.log('done');\n})\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introducded by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","_id":"co@1.0.0","dist":{"shasum":"e933dc090252deb8e6c20dd93d43d64c303bc700","tarball":"http://registry.npmjs.org/co/-/co-1.0.0.tgz"},"_from":".","_npmVersion":"1.2.21","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"1.1.0":{"name":"co","version":"1.1.0","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.10.0","q":"~0.9.4"},"license":"MIT","readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony` or `--harmony-generators` flags when\n  running node 0.11.x to get access to generators.\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  - [co-fs](https://github.com/visionmedia/co-fs) - core `fs` function wrappers\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})\n```\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n  This is what the `co.wrap(fn)` utility function does for you.\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` which is immediately invoked. Any `yield` expressions\n  within _must_ return a \"thunk\", at which point `co()` will defer execution.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\n#### Nesting co() calls\n\n  The `co()` function itself returns a thunk, this means you can nest appropriately:\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nvar foo = co(function *(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n})\n\nvar bar = co(function *(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n})\n\nco(function *(){\n  var a = yield foo;\n  var b = yield bar;\n  console.log(a);\n  console.log(b);\n});\n```\n\n  Or a variation of the same thing:\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = yield co(function *(){\n    var a = yield size('.gitignore');\n    var b = yield size('Makefile');\n    var c = yield size('package.json');\n    return [a, b, c];\n  })\n\n  var b = yield co(function *(){\n    var a = yield size('examples/parallel.js');\n    var b = yield size('examples/nested.js');\n    var c = yield size('examples/simple.js');\n    return [a, b, c];\n  })\n\n  console.log(a);\n  console.log(b);\n});\n```\n\n#### co() return values\n\n  Since `co()` returns a thunk, you may pass a function to this thunk\n  to receive the `return` values from the generator. Any error that occurs\n  is passed to this (`sizes`) function.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nvar sizes = co(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a.length, b.length, c.length];\n});\n\nsizes(function(err, res){\n  console.log(res);\n});\n```\n\n### co.wrap(fn, [ctx])\n\n  The `co.wrap()` utility simply wraps a node-style function to return a thunk.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile', 'ascii');\n  var c = yield read('package.json', 'utf8');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\nOptionally you may pass the `fn`'s receiver as the `ctx` as shown here:\n\n```js\n\nvar co = require('co')\nvar redis = require('redis')\nvar db = redis.createClient()\n\ndb.set = co.wrap(db.set, db)\ndb.get = co.wrap(db.get, db)\n\nco(function *(){\n  yield db.set('foo', 'bar')\n  yield db.set('bar', 'baz')\n\n  var res = yield db.get('foo')\n  console.log('foo -> %s', res);\n\n  var res = yield db.get('bar')\n  console.log('bar -> %s', res);\n})\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n## FAQ\n\n### How does this compare to taskjs?\n\n  - it's smaller\n  - it's not a scheduler\n  - you can use thunks (functions)\n  - you can use promises\n\n### Does it work with streams?\n\n  Not out of the box, but if you're willing to fight node a bit you can\n  wrestle streams into something usable:\n\n```js\nco(function *(){\n  var res = yield get('http://google.com');\n  console.log('-> %s', res.status);\n\n  var buf;\n  while (buf = yield res.read()) {\n    console.log(buf.toString());\n  }\n\n  console.log('done');\n})\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","_id":"co@1.1.0","dist":{"shasum":"ea07027c8f5230d400e662251924e52d8a234c6b","tarball":"http://registry.npmjs.org/co/-/co-1.1.0.tgz"},"_from":".","_npmVersion":"1.2.21","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"1.2.0":{"name":"co","version":"1.2.0","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.10.0","q":"~0.9.4"},"license":"MIT","readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony` or `--harmony-generators` flags when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator are\n  then either passed `co()`'s thunk or thrown.\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  - [co-fs](https://github.com/visionmedia/co-fs) - core `fs` function wrappers\n  - [co-exec](https://github.com/visionmedia/co-exec) - core `exec` function wrapper\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})\n```\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n  This is what the `co.wrap(fn)` utility function does for you.\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` which is immediately invoked. Any `yield` expressions\n  within _must_ return a \"thunk\", at which point `co()` will defer execution.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\n#### Nesting co() calls\n\n  The `co()` function itself returns a thunk, this means you can nest appropriately:\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nvar foo = co(function *(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n})\n\nvar bar = co(function *(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n})\n\nco(function *(){\n  var a = yield foo;\n  var b = yield bar;\n  console.log(a);\n  console.log(b);\n});\n```\n\n  Or a variation of the same thing:\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = yield co(function *(){\n    var a = yield size('.gitignore');\n    var b = yield size('Makefile');\n    var c = yield size('package.json');\n    return [a, b, c];\n  })\n\n  var b = yield co(function *(){\n    var a = yield size('examples/parallel.js');\n    var b = yield size('examples/nested.js');\n    var c = yield size('examples/simple.js');\n    return [a, b, c];\n  })\n\n  console.log(a);\n  console.log(b);\n});\n```\n\n#### co() return values\n\n  Since `co()` returns a thunk, you may pass a function to this thunk\n  to receive the `return` values from the generator. Any error that occurs\n  is passed to this (`sizes`) function.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nvar sizes = co(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a.length, b.length, c.length];\n});\n\nsizes(function(err, res){\n  console.log(res);\n});\n```\n\n### co.wrap(fn, [ctx])\n\n  The `co.wrap()` utility simply wraps a node-style function to return a thunk.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile', 'ascii');\n  var c = yield read('package.json', 'utf8');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\nOptionally you may pass the `fn`'s receiver as the `ctx` as shown here:\n\n```js\n\nvar co = require('co')\nvar redis = require('redis')\nvar db = redis.createClient()\n\ndb.set = co.wrap(db.set, db)\ndb.get = co.wrap(db.get, db)\n\nco(function *(){\n  yield db.set('foo', 'bar')\n  yield db.set('bar', 'baz')\n\n  var res = yield db.get('foo')\n  console.log('foo -> %s', res);\n\n  var res = yield db.get('bar')\n  console.log('bar -> %s', res);\n})\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n## FAQ\n\n### How does this compare to taskjs?\n\n  - it's smaller\n  - it's not a scheduler\n  - you can use thunks (functions)\n  - you can use promises\n\n### Does it work with streams?\n\n  Not out of the box, but if you're willing to fight node a bit you can\n  wrestle streams into something usable:\n\n```js\nco(function *(){\n  var res = yield get('http://google.com');\n  console.log('-> %s', res.status);\n\n  var buf;\n  while (buf = yield res.read()) {\n    console.log(buf.toString());\n  }\n\n  console.log('done');\n})\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","_id":"co@1.2.0","dist":{"shasum":"9af3eeef7c184eaad2456d2b016c0486270cc802","tarball":"http://registry.npmjs.org/co/-/co-1.2.0.tgz"},"_from":".","_npmVersion":"1.2.21","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"1.2.1":{"name":"co","version":"1.2.1","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.10.0","q":"~0.9.4"},"license":"MIT","readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony` or `--harmony-generators` flags when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator are\n  then either passed `co()`'s thunk or thrown.\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  - [co-fs](https://github.com/visionmedia/co-fs) - core `fs` function wrappers\n  - [co-exec](https://github.com/visionmedia/co-exec) - core `exec` function wrapper\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})\n```\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n  This is what the `co.wrap(fn)` utility function does for you.\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` which is immediately invoked. Any `yield` expressions\n  within _must_ return a \"thunk\", at which point `co()` will defer execution.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\n#### Nesting co() calls\n\n  The `co()` function itself returns a thunk, this means you can nest appropriately:\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nvar foo = co(function *(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n})\n\nvar bar = co(function *(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n})\n\nco(function *(){\n  var a = yield foo;\n  var b = yield bar;\n  console.log(a);\n  console.log(b);\n});\n```\n\n  Or a variation of the same thing:\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = yield co(function *(){\n    var a = yield size('.gitignore');\n    var b = yield size('Makefile');\n    var c = yield size('package.json');\n    return [a, b, c];\n  })\n\n  var b = yield co(function *(){\n    var a = yield size('examples/parallel.js');\n    var b = yield size('examples/nested.js');\n    var c = yield size('examples/simple.js');\n    return [a, b, c];\n  })\n\n  console.log(a);\n  console.log(b);\n});\n```\n\n#### co() return values\n\n  Since `co()` returns a thunk, you may pass a function to this thunk\n  to receive the `return` values from the generator. Any error that occurs\n  is passed to this (`sizes`) function.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nvar sizes = co(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a.length, b.length, c.length];\n});\n\nsizes(function(err, res){\n  console.log(res);\n});\n```\n\n### co.wrap(fn, [ctx])\n\n  The `co.wrap()` utility simply wraps a node-style function to return a thunk.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile', 'ascii');\n  var c = yield read('package.json', 'utf8');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\nOptionally you may pass the `fn`'s receiver as the `ctx` as shown here:\n\n```js\n\nvar co = require('co')\nvar redis = require('redis')\nvar db = redis.createClient()\n\ndb.set = co.wrap(db.set, db)\ndb.get = co.wrap(db.get, db)\n\nco(function *(){\n  yield db.set('foo', 'bar')\n  yield db.set('bar', 'baz')\n\n  var res = yield db.get('foo')\n  console.log('foo -> %s', res);\n\n  var res = yield db.get('bar')\n  console.log('bar -> %s', res);\n})\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n## FAQ\n\n### How does this compare to taskjs?\n\n  - it's smaller\n  - it's not a scheduler\n  - you can use thunks (functions)\n  - you can use promises\n\n### Does it work with streams?\n\n  Not out of the box, but if you're willing to fight node a bit you can\n  wrestle streams into something usable:\n\n```js\nco(function *(){\n  var res = yield get('http://google.com');\n  console.log('-> %s', res.status);\n\n  var buf;\n  while (buf = yield res.read()) {\n    console.log(buf.toString());\n  }\n\n  console.log('done');\n})\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","_id":"co@1.2.1","dist":{"shasum":"4ba2b738479a1a33087a755bd3499cbf945a9e5e","tarball":"http://registry.npmjs.org/co/-/co-1.2.1.tgz"},"_from":".","_npmVersion":"1.2.21","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"1.3.0":{"name":"co","version":"1.3.0","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.10.0","q":"~0.9.4"},"license":"MIT","readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony` or `--harmony-generators` flags when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator are\n  then either passed `co()`'s thunk or thrown.\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  - [co-fs](https://github.com/visionmedia/co-fs) - core `fs` function wrappers\n  - [co-exec](https://github.com/visionmedia/co-exec) - core `exec` function wrapper\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})\n```\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n  This is what the `co.wrap(fn)` utility function does for you.\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` which is immediately invoked. Any `yield` expressions\n  within _must_ return a \"thunk\", at which point `co()` will defer execution.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\n#### Nesting co() calls\n\n  The `co()` function itself returns a thunk, this means you can nest appropriately:\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nvar foo = co(function *(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n})\n\nvar bar = co(function *(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n})\n\nco(function *(){\n  var a = yield foo;\n  var b = yield bar;\n  console.log(a);\n  console.log(b);\n});\n```\n\n  Or a variation of the same thing:\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = yield co(function *(){\n    var a = yield size('.gitignore');\n    var b = yield size('Makefile');\n    var c = yield size('package.json');\n    return [a, b, c];\n  })\n\n  var b = yield co(function *(){\n    var a = yield size('examples/parallel.js');\n    var b = yield size('examples/nested.js');\n    var c = yield size('examples/simple.js');\n    return [a, b, c];\n  })\n\n  console.log(a);\n  console.log(b);\n});\n```\n\n#### co() return values\n\n  Since `co()` returns a thunk, you may pass a function to this thunk\n  to receive the `return` values from the generator. Any error that occurs\n  is passed to this (`sizes`) function.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nvar sizes = co(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a.length, b.length, c.length];\n});\n\nsizes(function(err, res){\n  console.log(res);\n});\n```\n\n### co.wrap(fn, [ctx])\n\n  The `co.wrap()` utility simply wraps a node-style function to return a thunk.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile', 'ascii');\n  var c = yield read('package.json', 'utf8');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\nOptionally you may pass the `fn`'s receiver as the `ctx` as shown here:\n\n```js\n\nvar co = require('co')\nvar redis = require('redis')\nvar db = redis.createClient()\n\ndb.set = co.wrap(db.set, db)\ndb.get = co.wrap(db.get, db)\n\nco(function *(){\n  yield db.set('foo', 'bar')\n  yield db.set('bar', 'baz')\n\n  var res = yield db.get('foo')\n  console.log('foo -> %s', res);\n\n  var res = yield db.get('bar')\n  console.log('bar -> %s', res);\n})\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n## FAQ\n\n### How does this compare to taskjs?\n\n  - it's smaller\n  - it's not a scheduler\n  - you can use thunks (functions)\n  - you can use promises\n\n### Does it work with streams?\n\n  Not out of the box, but if you're willing to fight node a bit you can\n  wrestle streams into something usable:\n\n```js\nco(function *(){\n  var res = yield get('http://google.com');\n  console.log('-> %s', res.status);\n\n  var buf;\n  while (buf = yield res.read()) {\n    console.log(buf.toString());\n  }\n\n  console.log('done');\n})\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","_id":"co@1.3.0","dist":{"shasum":"560ba5696f2477b2ce344cb0a3385de4f0a4c4e9","tarball":"http://registry.npmjs.org/co/-/co-1.3.0.tgz"},"_from":".","_npmVersion":"1.2.21","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"1.4.0":{"name":"co","version":"1.4.0","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.10.0","q":"~0.9.4"},"license":"MIT","readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony` or `--harmony-generators` flags when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator are\n  then either passed `co()`'s thunk or thrown.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  - [co-fs](https://github.com/visionmedia/co-fs) - core `fs` function wrappers\n  - [co-exec](https://github.com/visionmedia/co-exec) - core `exec` function wrapper\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n  This is what the `co.wrap(fn)` utility function does for you.\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` which is immediately invoked. Any `yield` expressions\n  within _must_ return a \"thunk\", at which point `co()` will defer execution.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n});\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar request = require('superagent');\n\nvar get = co.wrap(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n});\n```\n\n#### co() return values\n\n  Since `co()` returns a thunk, you may pass a function to this thunk\n  to receive the `return` values from the generator. Any error that occurs\n  is passed to this (`sizes`) function.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nvar sizes = co(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a.length, b.length, c.length];\n});\n\nsizes(function(err, res){\n  console.log(res);\n});\n```\n\n### co.wrap(fn, [ctx])\n\n  The `co.wrap()` utility simply wraps a node-style function to return a thunk.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile', 'ascii');\n  var c = yield read('package.json', 'utf8');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\nOptionally you may pass the `fn`'s receiver as the `ctx` as shown here:\n\n```js\n\nvar co = require('co')\nvar redis = require('redis')\nvar db = redis.createClient()\n\ndb.set = co.wrap(db.set, db)\ndb.get = co.wrap(db.get, db)\n\nco(function *(){\n  yield db.set('foo', 'bar')\n  yield db.set('bar', 'baz')\n\n  var res = yield db.get('foo')\n  console.log('foo -> %s', res);\n\n  var res = yield db.get('bar')\n  console.log('bar -> %s', res);\n})\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  Nested joins may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","_id":"co@1.4.0","dist":{"shasum":"3961dd2bae1f4666b60472b2f6712a37bc39482f","tarball":"http://registry.npmjs.org/co/-/co-1.4.0.tgz"},"_from":".","_npmVersion":"1.2.21","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"1.4.1":{"name":"co","version":"1.4.1","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.10.0","q":"~0.9.4"},"license":"MIT","readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony-generators` flag when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator are\n  then either passed `co()`'s thunk or thrown.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  - [co-fs](https://github.com/visionmedia/co-fs) - core `fs` function wrappers\n  - [co-exec](https://github.com/visionmedia/co-exec) - core `exec` function wrapper\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n  This is what the `co.wrap(fn)` utility function does for you.\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` which is immediately invoked. Any `yield` expressions\n  within _must_ return a \"thunk\", at which point `co()` will defer execution.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n});\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar request = require('superagent');\n\nvar get = co.wrap(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n});\n```\n\n#### co() return values\n\n  Since `co()` returns a thunk, you may pass a function to this thunk\n  to receive the `return` values from the generator. Any error that occurs\n  is passed to this (`sizes`) function.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nvar sizes = co(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a.length, b.length, c.length];\n});\n\nsizes(function(err, res){\n  console.log(res);\n});\n```\n\n### co.wrap(fn, [ctx])\n\n  The `co.wrap()` utility simply wraps a node-style function to return a thunk.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile', 'ascii');\n  var c = yield read('package.json', 'utf8');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\nOptionally you may pass the `fn`'s receiver as the `ctx` as shown here:\n\n```js\n\nvar co = require('co')\nvar redis = require('redis')\nvar db = redis.createClient()\n\ndb.set = co.wrap(db.set, db)\ndb.get = co.wrap(db.get, db)\n\nco(function *(){\n  yield db.set('foo', 'bar')\n  yield db.set('bar', 'baz')\n\n  var res = yield db.get('foo')\n  console.log('foo -> %s', res);\n\n  var res = yield db.get('bar')\n  console.log('bar -> %s', res);\n})\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  Nested joins may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","_id":"co@1.4.1","dist":{"shasum":"ad24a5c0fb4f832f05b1d24438b812ef7a2600b2","tarball":"http://registry.npmjs.org/co/-/co-1.4.1.tgz"},"_from":".","_npmVersion":"1.2.25","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"1.5.0":{"name":"co","version":"1.5.0","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.10.0","q":"~0.9.4","bench":"~0.3.5"},"license":"MIT","readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony-generators` flag when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator are\n  then either passed `co()`'s thunk or thrown.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  - [co-fs](https://github.com/visionmedia/co-fs) - core `fs` function wrappers\n  - [co-exec](https://github.com/visionmedia/co-exec) - core `exec` function wrapper\n  - [co-prompt](https://github.com/visionmedia/co-prompt) - terminal user input utilities\n  - [co-express](https://github.com/mciparelli/co-express) - [express](https://github.com/visionmedia/express) wrapper that enables generators to be used as middlewares\n  - [level-co](https://github.com/juliangruber/level-co) - levelup wrapper\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n  This is what the `co.wrap(fn)` utility function does for you.\n\n## Receiver propagation\n\n  When `co` is invoked with a receiver it will propagate to most yieldables,\n  allowing you to alter `this`.\n\n```js\nvar ctx = {};\n\nfunction foo() {\n  assert(this == ctx);\n}\n\nco.call(ctx, function *(){\n  assert(this == ctx);\n  yield foo;\n});\n```\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` which is immediately invoked. Any `yield` expressions\n  within _must_ return a \"thunk\", at which point `co()` will defer execution.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n});\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar request = require('superagent');\n\nvar get = co.wrap(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n});\n```\n\n#### co() return values\n\n  Since `co()` returns a thunk, you may pass a function to this thunk\n  to receive the `return` values from the generator. Any error that occurs\n  is passed to this (`sizes`) function.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nvar sizes = co(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a.length, b.length, c.length];\n});\n\nsizes(function(err, res){\n  console.log(res);\n});\n```\n\n### co.wrap(fn, [ctx])\n\n  The `co.wrap()` utility simply wraps a node-style function to return a thunk.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile', 'ascii');\n  var c = yield read('package.json', 'utf8');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\nOptionally you may pass the `fn`'s receiver as the `ctx` as shown here:\n\n```js\n\nvar co = require('co')\nvar redis = require('redis')\nvar db = redis.createClient()\n\ndb.set = co.wrap(db.set, db)\ndb.get = co.wrap(db.get, db)\n\nco(function *(){\n  yield db.set('foo', 'bar')\n  yield db.set('bar', 'baz')\n\n  var res = yield db.get('foo')\n  console.log('foo -> %s', res);\n\n  var res = yield db.get('bar')\n  console.log('bar -> %s', res);\n})\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  Nested joins may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","_id":"co@1.5.0","dist":{"shasum":"18447ddd69697266d2bd6d56fb7cf59581fc6d96","tarball":"http://registry.npmjs.org/co/-/co-1.5.0.tgz"},"_from":".","_npmVersion":"1.3.4","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"1.5.1":{"name":"co","version":"1.5.1","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.10.0","q":"~0.9.4","bench":"~0.3.5"},"license":"MIT","readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony-generators` flag when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator are\n  then either passed `co()`'s thunk or thrown.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  - [co-fs](https://github.com/visionmedia/co-fs) - core `fs` function wrappers\n  - [co-exec](https://github.com/visionmedia/co-exec) - core `exec` function wrapper\n  - [co-prompt](https://github.com/visionmedia/co-prompt) - terminal user input utilities\n  - [co-express](https://github.com/mciparelli/co-express) - [express](https://github.com/visionmedia/express) wrapper that enables generators to be used as middlewares\n  - [level-co](https://github.com/juliangruber/level-co) - levelup wrapper\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n  This is what the `co.wrap(fn)` utility function does for you.\n\n## Receiver propagation\n\n  When `co` is invoked with a receiver it will propagate to most yieldables,\n  allowing you to alter `this`.\n\n```js\nvar ctx = {};\n\nfunction foo() {\n  assert(this == ctx);\n}\n\nco.call(ctx, function *(){\n  assert(this == ctx);\n  yield foo;\n});\n```\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` which is immediately invoked. Any `yield` expressions\n  within _must_ return a \"thunk\", at which point `co()` will defer execution.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n});\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar request = require('superagent');\n\nvar get = co.wrap(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n});\n```\n\n#### co() return values\n\n  Since `co()` returns a thunk, you may pass a function to this thunk\n  to receive the `return` values from the generator. Any error that occurs\n  is passed to this (`sizes`) function.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nvar sizes = co(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a.length, b.length, c.length];\n});\n\nsizes(function(err, res){\n  console.log(res);\n});\n```\n\n### co.wrap(fn, [ctx])\n\n  The `co.wrap()` utility simply wraps a node-style function to return a thunk.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile', 'ascii');\n  var c = yield read('package.json', 'utf8');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\nOptionally you may pass the `fn`'s receiver as the `ctx` as shown here:\n\n```js\n\nvar co = require('co')\nvar redis = require('redis')\nvar db = redis.createClient()\n\ndb.set = co.wrap(db.set, db)\ndb.get = co.wrap(db.get, db)\n\nco(function *(){\n  yield db.set('foo', 'bar')\n  yield db.set('bar', 'baz')\n\n  var res = yield db.get('foo')\n  console.log('foo -> %s', res);\n\n  var res = yield db.get('bar')\n  console.log('bar -> %s', res);\n})\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  Nested joins may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","_id":"co@1.5.1","dist":{"shasum":"920ee4a4ae5bacf108be61cbb1a1468089ef640d","tarball":"http://registry.npmjs.org/co/-/co-1.5.1.tgz"},"_from":".","_npmVersion":"1.3.4","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"1.5.2":{"name":"co","version":"1.5.2","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.12.0","q":"~0.9.4","bench":"~0.3.5"},"license":"MIT","repository":{"type":"git","url":"https://github.com/visionmedia/co.git"},"readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony-generators` flag when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator are\n  then either passed `co()`'s thunk or thrown.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  - [co-fs](https://github.com/visionmedia/co-fs) - core `fs` function wrappers\n  - [co-exec](https://github.com/visionmedia/co-exec) - core `exec` function wrapper\n  - [co-prompt](https://github.com/visionmedia/co-prompt) - terminal user input utilities\n  - [co-express](https://github.com/mciparelli/co-express) - [express](https://github.com/visionmedia/express) wrapper that enables generators to be used as middlewares\n  - [level-co](https://github.com/juliangruber/level-co) - levelup wrapper\n  - [mysql-co](https://github.com/sidorares/mysql-co) - mysql wrapper\n  - [co-each](https://github.com/juliangruber/co-each) - parallel foreach\n  - [co-wait](https://github.com/juliangruber/co-wait) - setTimeout wrapper\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n  This is what the `co.wrap(fn)` utility function does for you.\n\n## Receiver propagation\n\n  When `co` is invoked with a receiver it will propagate to most yieldables,\n  allowing you to alter `this`.\n\n```js\nvar ctx = {};\n\nfunction foo() {\n  assert(this == ctx);\n}\n\nco.call(ctx, function *(){\n  assert(this == ctx);\n  yield foo;\n});\n```\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` which is immediately invoked. Any `yield` expressions\n  within _must_ return a \"thunk\", at which point `co()` will defer execution.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n});\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar request = require('superagent');\n\nvar get = co.wrap(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n});\n```\n\n#### co() return values\n\n  Since `co()` returns a thunk, you may pass a function to this thunk\n  to receive the `return` values from the generator. Any error that occurs\n  is passed to this (`sizes`) function.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nvar sizes = co(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a.length, b.length, c.length];\n});\n\nsizes(function(err, res){\n  console.log(res);\n});\n```\n\n### co.wrap(fn, [ctx])\n\n  The `co.wrap()` utility simply wraps a node-style function to return a thunk.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile', 'ascii');\n  var c = yield read('package.json', 'utf8');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\nAn example with redis:\n\n```js\n\nvar co = require('co')\nvar redis = require('redis')\nvar db = redis.createClient()\n\ndb.set = co.wrap(db.set)\ndb.get = co.wrap(db.get)\n\nco(function *(){\n  yield db.set('foo', 'bar')\n  yield db.set('bar', 'baz')\n\n  var res = yield db.get('foo')\n  console.log('foo -> %s', res);\n\n  var res = yield db.get('bar')\n  console.log('bar -> %s', res);\n})\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  Nested joins may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","bugs":{"url":"https://github.com/visionmedia/co/issues"},"_id":"co@1.5.2","dist":{"shasum":"58c6d84e664fc82e363d12f36afbf3dc8d0b4879","tarball":"http://registry.npmjs.org/co/-/co-1.5.2.tgz"},"_from":".","_npmVersion":"1.3.8","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"2.0.0":{"name":"co","version":"2.0.0","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.12.0","q":"~0.9.4","thunkify":"0.0.1","request":"~2.27.0","matcha":"visionmedia/matcha"},"license":"MIT","repository":{"type":"git","url":"https://github.com/visionmedia/co.git"},"readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony-generators` flag when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator are\n  then either passed `co()`'s thunk or thrown.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  View the [wiki](https://github.com/visionmedia/co/wiki) for libraries that \n  work well with Co.\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})()\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})()\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\n To convert a regular node function that accepts a callback\n into one which returns a thunk you may want to use [thunkify](https://github.com/visionmedia/node-thunkify) or similar.\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n## Receiver propagation\n\n  When `co` is invoked with a receiver it will propagate to most yieldables,\n  allowing you to alter `this`.\n\n```js\nvar ctx = {};\n\nfunction foo() {\n  assert(this == ctx);\n}\n\nco.call(ctx, function *(){\n  assert(this == ctx);\n  yield foo;\n});\n```\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` and return a thunk. The thunk's signature is\n  `(err, result)`, where `result` is the value passed to the `return`\n  statement.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a, b, c];\n})()\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n});\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar thunkify = require('thunkify');\nvar request = require('superagent');\n\nvar get = thunkify(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n})()\n```\n\n  If a thunk is written to execute immediately you may acheive parallelism \n  by simply `yield`-ing _after_ the call. The following are equivalent since\n  each call kicks off execution immediately:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return [yield a, yield b, yield c];\n})()\n```\n\n  Or using join:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return yield [a, b, c];\n})()\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  Nested joins may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","bugs":{"url":"https://github.com/visionmedia/co/issues"},"_id":"co@2.0.0","dist":{"shasum":"1761e3a6c650f53c22f9ac7ef6ea3b404789a1b6","tarball":"http://registry.npmjs.org/co/-/co-2.0.0.tgz"},"_from":".","_npmVersion":"1.3.8","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"2.1.0":{"name":"co","version":"2.1.0","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.12.0","q":"~0.9.4","thunkify":"0.0.1","request":"~2.27.0","matcha":"~0.4.0"},"license":"MIT","repository":{"type":"git","url":"https://github.com/visionmedia/co.git"},"readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony-generators` flag when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator\n  are passed to `co()`'s thunk.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  View the [wiki](https://github.com/visionmedia/co/wiki) for libraries that\n  work well with Co.\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})()\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})()\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\n To convert a regular node function that accepts a callback\n into one which returns a thunk you may want to use [thunkify](https://github.com/visionmedia/node-thunkify) or similar.\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n## Receiver propagation\n\n  When `co` is invoked with a receiver it will propagate to most yieldables,\n  allowing you to alter `this`.\n\n```js\nvar ctx = {};\n\nfunction foo() {\n  assert(this == ctx);\n}\n\nco.call(ctx, function *(){\n  assert(this == ctx);\n  yield foo;\n});\n```\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` and return a thunk. The thunk's signature is\n  `(err, result)`, where `result` is the value passed to the `return`\n  statement.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a, b, c];\n})()\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n})()\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar thunkify = require('thunkify');\nvar request = require('superagent');\n\nvar get = thunkify(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n})()\n```\n\n  If a thunk is written to execute immediately you may acheive parallelism\n  by simply `yield`-ing _after_ the call. The following are equivalent since\n  each call kicks off execution immediately:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return [yield a, yield b, yield c];\n})()\n```\n\n  Or using join:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return yield [a, b, c];\n})()\n```\n\n  You can also pass arguments into the generator. The last argument, `done`, is\n  the callback function. Here's an example:\n\n```js\nvar exec = require('co-exec');\nco(function *(cmd) {\n  var res = yield exec(cmd);\n  return res;\n})('pwd', done);\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  Nested joins may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","bugs":{"url":"https://github.com/visionmedia/co/issues"},"_id":"co@2.1.0","dist":{"shasum":"6c21ed3acc2539f64840f31304bc20d240fb7058","tarball":"http://registry.npmjs.org/co/-/co-2.1.0.tgz"},"_from":".","_npmVersion":"1.3.8","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"2.2.0":{"name":"co","version":"2.2.0","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.12.0","q":"~0.9.4","thunkify":"0.0.1","request":"~2.27.0","matcha":"~0.4.0"},"license":"MIT","repository":{"type":"git","url":"https://github.com/visionmedia/co.git"},"readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony-generators` flag when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator\n  are passed to `co()`'s thunk.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  View the [wiki](https://github.com/visionmedia/co/wiki) for libraries that\n  work well with Co.\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})()\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})()\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\n To convert a regular node function that accepts a callback\n into one which returns a thunk you may want to use [thunkify](https://github.com/visionmedia/node-thunkify) or similar.\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n## Receiver propagation\n\n  When `co` is invoked with a receiver it will propagate to most yieldables,\n  allowing you to alter `this`.\n\n```js\nvar ctx = {};\n\nfunction foo() {\n  assert(this == ctx);\n}\n\nco.call(ctx, function *(){\n  assert(this == ctx);\n  yield foo;\n})()\n```\n\n  You also pass arguments through the generator:\n\n```js\nco.call(ctx, function *(a){\n  assert(this == ctx);\n  assert('yay' == a);\n  yield foo;\n})('yay');\n```\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` and return a thunk. The thunk's signature is\n  `(err, result)`, where `result` is the value passed to the `return`\n  statement.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a, b, c];\n})()\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n})()\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar thunkify = require('thunkify');\nvar request = require('superagent');\n\nvar get = thunkify(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n})()\n```\n\n  If a thunk is written to execute immediately you may acheive parallelism\n  by simply `yield`-ing _after_ the call. The following are equivalent since\n  each call kicks off execution immediately:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return [yield a, yield b, yield c];\n})()\n```\n\n  Or using join:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return yield [a, b, c];\n})()\n```\n\n  You can also pass arguments into the generator. The last argument, `done`, is\n  the callback function. Here's an example:\n\n```js\nvar exec = require('co-exec');\nco(function *(cmd) {\n  var res = yield exec(cmd);\n  return res;\n})('pwd', done);\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  Nested joins may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","bugs":{"url":"https://github.com/visionmedia/co/issues"},"homepage":"https://github.com/visionmedia/co","_id":"co@2.2.0","dist":{"shasum":"8e48dd1d23e523426bca4613b37161fd9a230039","tarball":"http://registry.npmjs.org/co/-/co-2.2.0.tgz"},"_from":".","_npmVersion":"1.3.13","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"2.3.0":{"name":"co","version":"2.3.0","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.12.0","q":"~0.9.4","thunkify":"0.0.1","request":"~2.27.0","matcha":"~0.4.0"},"scripts":{"test":"make test"},"license":"MIT","repository":{"type":"git","url":"https://github.com/visionmedia/co.git"},"readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony-generators` flag when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator\n  are passed to `co()`'s thunk.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  View the [wiki](https://github.com/visionmedia/co/wiki) for libraries that\n  work well with Co.\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})()\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})()\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\n To convert a regular node function that accepts a callback\n into one which returns a thunk you may want to use [thunkify](https://github.com/visionmedia/node-thunkify) or similar.\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n## Receiver propagation\n\n  When `co` is invoked with a receiver it will propagate to most yieldables,\n  allowing you to alter `this`.\n\n```js\nvar ctx = {};\n\nfunction foo() {\n  assert(this == ctx);\n}\n\nco.call(ctx, function *(){\n  assert(this == ctx);\n  yield foo;\n})()\n```\n\n  You also pass arguments through the generator:\n\n```js\nco.call(ctx, function *(a){\n  assert(this == ctx);\n  assert('yay' == a);\n  yield foo;\n})('yay');\n```\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` and return a thunk. The thunk's signature is\n  `(err, result)`, where `result` is the value passed to the `return`\n  statement.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a, b, c];\n})()\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n})()\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar thunkify = require('thunkify');\nvar request = require('superagent');\n\nvar get = thunkify(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n})()\n```\n\n  If a thunk is written to execute immediately you may acheive parallelism\n  by simply `yield`-ing _after_ the call. The following are equivalent since\n  each call kicks off execution immediately:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return [yield a, yield b, yield c];\n})()\n```\n\n  Or using join:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return yield [a, b, c];\n})()\n```\n\n  You can also pass arguments into the generator. The last argument, `done`, is\n  the callback function. Here's an example:\n\n```js\nvar exec = require('co-exec');\nco(function *(cmd) {\n  var res = yield exec(cmd);\n  return res;\n})('pwd', done);\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n  Nested joins may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","bugs":{"url":"https://github.com/visionmedia/co/issues"},"homepage":"https://github.com/visionmedia/co","_id":"co@2.3.0","dist":{"shasum":"4b71a77a11806982593e73f60a51a89da26bdf9a","tarball":"http://registry.npmjs.org/co/-/co-2.3.0.tgz"},"_from":".","_npmVersion":"1.3.13","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"3.0.0":{"name":"co","version":"3.0.0","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.12.0","q":"~0.9.4","thunkify":"0.0.1","request":"~2.27.0","matcha":"~0.4.0"},"scripts":{"test":"make test"},"license":"MIT","repository":{"type":"git","url":"https://github.com/visionmedia/co.git"},"readme":"# Co\n\n  [![Build Status](https://travis-ci.org/visionmedia/co.png)](https://travis-ci.org/visionmedia/co)\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony-generators` flag when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator\n  are passed to `co()`'s thunk.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  View the [wiki](https://github.com/visionmedia/co/wiki) for libraries that\n  work well with Co.\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})()\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})()\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - objects (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\nTo convert a regular node function that accepts a callback into one which returns a thunk you may want to use [thunkify](https://github.com/visionmedia/node-thunkify) or similar.\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n## Receiver propagation\n\n  When `co` is invoked with a receiver it will propagate to most yieldables,\n  allowing you to alter `this`.\n\n```js\nvar ctx = {};\n\nfunction foo() {\n  assert(this == ctx);\n}\n\nco(function *(){\n  assert(this == ctx);\n  yield foo;\n}).call(ctx)\n```\n\n  You also pass arguments through the generator:\n\n```js\nco(function *(a){\n  assert(this == ctx);\n  assert('yay' == a);\n  yield foo;\n}).call(ctx, 'yay');\n```\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` and return a thunk. The thunk's signature is\n  `(err, result)`, where `result` is the value passed to the `return`\n  statement.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a, b, c];\n})()\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n})()\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar thunkify = require('thunkify');\nvar request = require('superagent');\n\nvar get = thunkify(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n})()\n```\n\n  If a thunk is written to execute immediately you may acheive parallelism\n  by simply `yield`-ing _after_ the call. The following are equivalent since\n  each call kicks off execution immediately:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return [yield a, yield b, yield c];\n})()\n```\n\n  Or using join:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return yield [a, b, c];\n})()\n```\n\n  You can also pass arguments into the generator. The last argument, `done`, is\n  the callback function. Here's an example:\n\n```js\nvar exec = require('co-exec');\nco(function *(cmd) {\n  var res = yield exec(cmd);\n  return res;\n})('pwd', done);\n```\n\n### yield array\n\n  By yielding an array of thunks you may \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n})()\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n})()\n```\n\n  Nested joins may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### yield object\n\n  Yielding an object behaves much like yielding an array, however recursion is supported:\n\n```js\nco(function *(){\n  var user = yield {\n    name: {\n      first: get('name.first'),\n      last: get('name.last')\n    }\n  };\n})()\n```\n\n  Here is the sequential equivalent without yielding an object:\n\n```js\nco(function *(){\n  var user = {\n    name: {\n      first: yield get('name.first'),\n      last: yield get('name.last')\n    }\n  };\n})()\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","bugs":{"url":"https://github.com/visionmedia/co/issues"},"homepage":"https://github.com/visionmedia/co","_id":"co@3.0.0","dist":{"shasum":"402d52a16ad231c0a15741fabbbde5297b637a8c","tarball":"http://registry.npmjs.org/co/-/co-3.0.0.tgz"},"_from":".","_npmVersion":"1.3.15","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"3.0.1":{"name":"co","version":"3.0.1","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.12.0","q":"~0.9.4","thunkify":"0.0.1","request":"~2.27.0","matcha":"~0.4.0"},"scripts":{"test":"make test"},"license":"MIT","repository":{"type":"git","url":"https://github.com/visionmedia/co.git"},"readme":"# Co\n\n  [![Build Status](https://travis-ci.org/visionmedia/co.png)](https://travis-ci.org/visionmedia/co)\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony-generators` flag when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator\n  are passed to `co()`'s thunk.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  View the [wiki](https://github.com/visionmedia/co/wiki) for libraries that\n  work well with Co.\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})()\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})()\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - objects (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\nTo convert a regular node function that accepts a callback into one which returns a thunk you may want to use [thunkify](https://github.com/visionmedia/node-thunkify) or similar.\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n## Receiver propagation\n\n  When `co` is invoked with a receiver it will propagate to most yieldables,\n  allowing you to alter `this`.\n\n```js\nvar ctx = {};\n\nfunction foo() {\n  assert(this == ctx);\n}\n\nco(function *(){\n  assert(this == ctx);\n  yield foo;\n}).call(ctx)\n```\n\n  You also pass arguments through the generator:\n\n```js\nco(function *(a){\n  assert(this == ctx);\n  assert('yay' == a);\n  yield foo;\n}).call(ctx, 'yay');\n```\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` and return a thunk. The thunk's signature is\n  `(err, result)`, where `result` is the value passed to the `return`\n  statement.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a, b, c];\n})()\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n})()\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar thunkify = require('thunkify');\nvar request = require('superagent');\n\nvar get = thunkify(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n})()\n```\n\n  If a thunk is written to execute immediately you may acheive parallelism\n  by simply `yield`-ing _after_ the call. The following are equivalent since\n  each call kicks off execution immediately:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return [yield a, yield b, yield c];\n})()\n```\n\n  Or using join:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return yield [a, b, c];\n})()\n```\n\n  You can also pass arguments into the generator. The last argument, `done`, is\n  the callback function. Here's an example:\n\n```js\nvar exec = require('co-exec');\nco(function *(cmd) {\n  var res = yield exec(cmd);\n  return res;\n})('pwd', done);\n```\n\n### yield array\n\n  By yielding an array of thunks you may \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n})()\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n})()\n```\n\n  Nested joins may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### yield object\n\n  Yielding an object behaves much like yielding an array, however recursion is supported:\n\n```js\nco(function *(){\n  var user = yield {\n    name: {\n      first: get('name.first'),\n      last: get('name.last')\n    }\n  };\n})()\n```\n\n  Here is the sequential equivalent without yielding an object:\n\n```js\nco(function *(){\n  var user = {\n    name: {\n      first: yield get('name.first'),\n      last: yield get('name.last')\n    }\n  };\n})()\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","bugs":{"url":"https://github.com/visionmedia/co/issues"},"homepage":"https://github.com/visionmedia/co","_id":"co@3.0.1","dist":{"shasum":"72cd4f7a67fd5adf740f18e8915435eadf9cb81e","tarball":"http://registry.npmjs.org/co/-/co-3.0.1.tgz"},"_from":".","_npmVersion":"1.3.15","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}},"3.0.2":{"name":"co","version":"3.0.2","description":"generator async flow control goodness","keywords":["async","flow","generator","coro","coroutine"],"devDependencies":{"should":"~1.2.2","mocha":"~1.12.0","q":"~0.9.4","thunkify":"0.0.1","request":"~2.27.0","matcha":"~0.4.0"},"scripts":{"test":"make test"},"license":"MIT","repository":{"type":"git","url":"https://github.com/visionmedia/co.git"},"readme":"# Co\n\n  [![Build Status](https://travis-ci.org/visionmedia/co.png)](https://travis-ci.org/visionmedia/co)\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony-generators` flag when\n  running node 0.11.x to get access to generators.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator\n  are passed to `co()`'s thunk.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  View the [wiki](https://github.com/visionmedia/co/wiki) for libraries that\n  work well with Co.\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})()\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})()\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - objects (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\nTo convert a regular node function that accepts a callback into one which returns a thunk you may want to use [thunkify](https://github.com/visionmedia/node-thunkify) or similar.\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n## Receiver propagation\n\n  When `co` is invoked with a receiver it will propagate to most yieldables,\n  allowing you to alter `this`.\n\n```js\nvar ctx = {};\n\nfunction foo() {\n  assert(this == ctx);\n}\n\nco(function *(){\n  assert(this == ctx);\n  yield foo;\n}).call(ctx)\n```\n\n  You also pass arguments through the generator:\n\n```js\nco(function *(a){\n  assert(this == ctx);\n  assert('yay' == a);\n  yield foo;\n}).call(ctx, 'yay');\n```\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` and return a thunk. The thunk's signature is\n  `(err, result)`, where `result` is the value passed to the `return`\n  statement.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a, b, c];\n})()\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n})()\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar thunkify = require('thunkify');\nvar request = require('superagent');\n\nvar get = thunkify(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n})()\n```\n\n  If a thunk is written to execute immediately you may acheive parallelism\n  by simply `yield`-ing _after_ the call. The following are equivalent since\n  each call kicks off execution immediately:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return [yield a, yield b, yield c];\n})()\n```\n\n  Or using join:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return yield [a, b, c];\n})()\n```\n\n  You can also pass arguments into the generator. The last argument, `done`, is\n  the callback function. Here's an example:\n\n```js\nvar exec = require('co-exec');\nco(function *(cmd) {\n  var res = yield exec(cmd);\n  return res;\n})('pwd', done);\n```\n\n### yield array\n\n  By yielding an array of thunks you may \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n})()\n```\n\n  As an alias of `join(array)` you may simply `yield` an array:\n\n```js\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n})()\n```\n\n  Nested joins may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### yield object\n\n  Yielding an object behaves much like yielding an array, however recursion is supported:\n\n```js\nco(function *(){\n  var user = yield {\n    name: {\n      first: get('name.first'),\n      last: get('name.last')\n    }\n  };\n})()\n```\n\n  Here is the sequential equivalent without yielding an object:\n\n```js\nco(function *(){\n  var user = {\n    name: {\n      first: yield get('name.first'),\n      last: yield get('name.last')\n    }\n  };\n})()\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","readmeFilename":"Readme.md","bugs":{"url":"https://github.com/visionmedia/co/issues"},"homepage":"https://github.com/visionmedia/co","_id":"co@3.0.2","dist":{"shasum":"bcc8a0fe3ea37fc69b15805de593d2b0d01732ba","tarball":"http://registry.npmjs.org/co/-/co-3.0.2.tgz"},"_from":".","_npmVersion":"1.3.15","_npmUser":{"name":"tjholowaychuk","email":"tj@vision-media.ca"},"maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"directories":{}}},"readme":"# Co\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks instead of promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony` or `--harmony-generators` flags when\n  running node 0.11.x to get access to generators.\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  - [co-fs](https://github.com/visionmedia/co-fs) - core `fs` function wrappers\n\n## Example\n\n```js\nvar co = require('co');\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})\n```\n\n## Why not promises?\n\n  I'm not a fan of promises personally, but preferences aside this\n  is an extremely minimal layer between the traditional node `(err, result)`\n  style callback using thunks. All you need to do is return a function, this\n  function behaves as the \"thunk\" or \"future\" that is `yield`ed to Co.\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n  This is what the `co.wrap(fn)` utility function does for you.\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` which is immediately invoked. Any `yield` expressions\n  within _must_ return a \"thunk\", at which point `co()` will defer execution.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\n#### Nesting co() calls\n\n  The `co()` function itself returns a thunk, this means you can nest appropriately:\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nvar foo = co(function *(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n})\n\nvar bar = co(function *(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n})\n\nco(function *(){\n  var a = yield foo;\n  var b = yield bar;\n  console.log(a);\n  console.log(b);\n});\n```\n\n  Or a variation of the same thing:\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = yield co(function *(){\n    var a = yield size('.gitignore');\n    var b = yield size('Makefile');\n    var c = yield size('package.json');\n    return [a, b, c];\n  })\n\n  var b = yield co(function *(){\n    var a = yield size('examples/parallel.js');\n    var b = yield size('examples/nested.js');\n    var c = yield size('examples/simple.js');\n    return [a, b, c];\n  })\n\n  console.log(a);\n  console.log(b);\n});\n```\n\n#### co() return values\n\n  Since `co()` returns a thunk, you may pass a function to this thunk\n  to receive the `return` values from the generator. Any error that occurs\n  is passed to this (`sizes`) function.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nvar sizes = co(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a.length, b.length, c.length];\n});\n\nsizes(function(err, res){\n  console.log(res);\n});\n```\n\n### co.wrap(fn, [ctx])\n\n  The `co.wrap()` utility simply wraps a node-style function to return a thunk.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nvar read = co.wrap(fs.readFile);\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile', 'ascii');\n  var c = yield read('package.json', 'utf8');\n  console.log(a);\n  console.log(b);\n  console.log(c);\n});\n```\n\nOptionally you may pass the `fn`'s receiver as the `ctx` as shown here:\n\n```js\n\nvar co = require('co')\nvar redis = require('redis')\nvar db = redis.createClient()\n\ndb.set = co.wrap(db.set, db)\ndb.get = co.wrap(db.get, db)\n\nco(function *(){\n  yield db.set('foo', 'bar')\n  yield db.set('bar', 'baz')\n\n  var res = yield db.get('foo')\n  console.log('foo -> %s', res);\n\n  var res = yield db.get('bar')\n  console.log('bar -> %s', res);\n})\n```\n\n### co.join(fn...)\n\n  The `co.join()` utility function allows you to pass multiple thunks, or an array\n  of thunks and \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar join = co.join;\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield join(a, b, c);\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n});\n```\n\n## FAQ\n\n### How does this compare to taskjs?\n\n  - it's smaller\n  - it's not a scheduler\n  - it doesn't use promises\n\n### What's this \"yielded a non-function\" error?\n\n  If you get this error it means that you're passing\n  a value that is _not_ a function to `yield`, for example\n  `yield \"something\"`, which has no meaning to `co`.\n\n### Does it work with streams?\n\n  Not out of the box, but if you're willing to fight node a bit you can\n  wrestle streams into something usable:\n\n```js\nco(function *(){\n  var res = yield get('http://google.com');\n  console.log('-> %s', res.status);\n\n  var buf;\n  while (buf = yield res.read()) {\n    console.log(buf.toString());\n  }\n\n  console.log('done');\n})\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introducded by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n","maintainers":[{"name":"tjholowaychuk","email":"tj@vision-media.ca"}],"time":{"1.0.0":"2013-06-06T20:24:55.133Z","1.1.0":"2013-06-06T23:38:03.571Z","1.2.0":"2013-06-08T19:45:46.699Z","1.2.1":"2013-06-09T00:55:34.844Z","1.3.0":"2013-06-10T20:43:35.738Z","1.4.0":"2013-06-22T06:21:46.429Z","1.4.1":"2013-07-01T20:35:38.141Z","1.5.0":"2013-08-10T02:18:06.732Z","1.5.1":"2013-08-11T00:39:21.029Z","1.5.2":"2013-09-02T17:26:47.678Z","2.0.0":"2013-10-14T23:39:36.083Z","2.1.0":"2013-10-21T20:22:10.304Z","2.2.0":"2013-11-06T00:46:00.108Z","2.3.0":"2013-11-12T20:34:24.575Z","3.0.0":"2013-12-20T04:04:19.381Z","3.0.1":"2013-12-20T05:23:05.400Z","3.0.2":"2014-01-02T17:16:33.430Z"},"repository":{"type":"git","url":"https://github.com/visionmedia/co.git"},"users":{"forivall":true,"nickleefly":true},"_attachments":{},"_etag":"\"3LVNP0MFYEIOIT5D42ILMWT9\""}